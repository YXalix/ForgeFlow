//! CLI parsing module
//!
//! Uses clap to parse command line arguments

use clap::{Args, Parser, Subcommand};

/// VKT command line arguments
#[derive(Parser, Debug)]
#[command(name = "vkt")]
#[command(about = "Virt-Kernel-Tools: Virtualization and kernel development productivity tool")]
#[command(version = env!("CARGO_PKG_VERSION"))]
#[command(author = env!("CARGO_PKG_AUTHORS"))]
pub struct Cli {
    /// Enable verbose logging
    #[arg(short, long, global = true, help = "Display detailed log information")]
    pub verbose: bool,

    /// Configuration file path
    #[arg(short, long, global = true, help = "Specify configuration file path")]
    pub config: Option<String>,

    /// Subcommand
    #[command(subcommand)]
    pub command: Commands,
}

/// Available subcommands
#[derive(Subcommand, Debug)]
pub enum Commands {
    /// List remote repository contents
    ///
    /// Examples:
    ///   vkt list              # List root directory
    ///   vkt list scripts/     # List specified directory
    List(ListArgs),

    /// Get remote file or directory
    ///
    /// Examples:
    ///   vkt get config.toml                    # Get file to current directory
    ///   vkt get scripts/qemu.sh -o ./local/    # Get to specified directory
    Get(GetArgs),

    /// Submit files to remote repository and create PR
    ///
    /// This is VKT's core feature - automatically submit local files to remote repository and create MR/PR.
    ///
    /// Examples:
    ///   vkt submit ./debug.sh --target scripts/ --msg "feat: add debug script"
    ///   vkt submit ./config/ --target configs/ --msg "chore: update configs" --force
    Submit(SubmitArgs),
}

/// list command arguments
#[derive(Args, Debug, Clone)]
pub struct ListArgs {
    /// Remote directory path (defaults to root)
    #[arg(value_name = "PATH", help = "Remote directory path to list")]
    pub path: Option<String>,

    /// Recursively list subdirectories
    #[arg(short, long, help = "Recursively list all subdirectories")]
    pub recursive: bool,
}

/// get command arguments
#[derive(Args, Debug, Clone)]
pub struct GetArgs {
    /// Remote file or directory path
    #[arg(value_name = "REMOTE_PATH", help = "Remote file or directory path")]
    pub path: String,

    /// Local save path (defaults to current directory)
    #[arg(short, long, value_name = "LOCAL_PATH", help = "Local save path")]
    pub output: Option<String>,

    /// Force overwrite existing files
    #[arg(short, long, help = "Force overwrite existing files")]
    pub force: bool,
}

/// submit command arguments
#[derive(Args, Debug, Clone)]
pub struct SubmitArgs {
    /// Local file or directory path
    #[arg(
        value_name = "LOCAL_PATH",
        help = "Local file or directory path to submit"
    )]
    pub local_path: String,

    /// Target remote directory
    #[arg(
        short,
        long,
        value_name = "REMOTE_DIR",
        help = "Remote target directory"
    )]
    pub target: String,

    /// Commit message
    #[arg(short, long, value_name = "MESSAGE", help = "Commit message")]
    pub msg: String,

    /// Force submit (skip confirmation)
    #[arg(short, long, help = "Force submit, skip confirmation prompt")]
    pub force: bool,

    /// Dry run only (preview without executing)
    #[arg(long, help = "Preview operations without actually executing")]
    pub dry_run: bool,

    /// Specify branch name (auto-generated by default)
    #[arg(short, long, value_name = "BRANCH", help = "Specify branch name")]
    pub branch: Option<String>,
}

/// Parse command line arguments
pub fn parse_args() -> Cli {
    Cli::parse()
}

/// Parse arguments from string slice (for testing)
pub fn parse_args_from(args: &[&str]) -> Result<Cli, clap::Error> {
    Cli::try_parse_from(args)
}

#[cfg(test)]
mod tests {
    use super::*;
    use clap::CommandFactory;

    #[test]
    fn test_cli_parsing() {
        // Verify CLI can be parsed correctly
        Cli::command().debug_assert();
    }

    #[test]
    fn test_list_command() {
        let cli = parse_args_from(&["vkt", "list"]).unwrap();
        match cli.command {
            Commands::List(args) => {
                assert!(args.path.is_none());
                assert!(!args.recursive);
            }
            _ => panic!("Expected List command"),
        }
    }

    #[test]
    fn test_list_with_path() {
        let cli = parse_args_from(&["vkt", "list", "scripts/"]).unwrap();
        match cli.command {
            Commands::List(args) => {
                assert_eq!(args.path, Some("scripts/".to_string()));
            }
            _ => panic!("Expected List command"),
        }
    }

    #[test]
    fn test_list_recursive() {
        let cli = parse_args_from(&["vkt", "list", "-r", "scripts/"]).unwrap();
        match cli.command {
            Commands::List(args) => {
                assert!(args.recursive);
                assert_eq!(args.path, Some("scripts/".to_string()));
            }
            _ => panic!("Expected List command"),
        }
    }

    #[test]
    fn test_get_command() {
        let cli = parse_args_from(&["vkt", "get", "config.toml"]).unwrap();
        match cli.command {
            Commands::Get(args) => {
                assert_eq!(args.path, "config.toml");
                assert!(args.output.is_none());
                assert!(!args.force);
            }
            _ => panic!("Expected Get command"),
        }
    }

    #[test]
    fn test_get_with_output() {
        let cli = parse_args_from(&["vkt", "get", "config.toml", "-o", "/tmp/"]).unwrap();
        match cli.command {
            Commands::Get(args) => {
                assert_eq!(args.path, "config.toml");
                assert_eq!(args.output, Some("/tmp/".to_string()));
            }
            _ => panic!("Expected Get command"),
        }
    }

    #[test]
    fn test_get_force() {
        let cli = parse_args_from(&["vkt", "get", "config.toml", "-f"]).unwrap();
        match cli.command {
            Commands::Get(args) => {
                assert!(args.force);
            }
            _ => panic!("Expected Get command"),
        }
    }

    #[test]
    fn test_submit_command() {
        let cli = parse_args_from(&[
            "vkt",
            "submit",
            "./local.sh",
            "--target",
            "scripts/",
            "--msg",
            "feat: add script",
        ])
        .unwrap();
        match cli.command {
            Commands::Submit(args) => {
                assert_eq!(args.local_path, "./local.sh");
                assert_eq!(args.target, "scripts/");
                assert_eq!(args.msg, "feat: add script");
                assert!(!args.force);
                assert!(!args.dry_run);
            }
            _ => panic!("Expected Submit command"),
        }
    }

    #[test]
    fn test_submit_with_options() {
        let cli = parse_args_from(&[
            "vkt",
            "submit",
            "./local.sh",
            "--target",
            "scripts/",
            "--msg",
            "feat: add script",
            "--force",
            "--dry-run",
            "--branch",
            "feat/add-script",
        ])
        .unwrap();
        match cli.command {
            Commands::Submit(args) => {
                assert!(args.force);
                assert!(args.dry_run);
                assert_eq!(args.branch, Some("feat/add-script".to_string()));
            }
            _ => panic!("Expected Submit command"),
        }
    }

    #[test]
    fn test_verbose_flag() {
        let cli = parse_args_from(&["vkt", "-v", "list"]).unwrap();
        assert!(cli.verbose);
    }

    #[test]
    fn test_config_flag() {
        let cli = parse_args_from(&["vkt", "-c", "/path/to/config.toml", "list"]).unwrap();
        assert_eq!(cli.config, Some("/path/to/config.toml".to_string()));
    }

    #[test]
    fn test_missing_required_arg() {
        // submit missing required --target
        let result = parse_args_from(&["vkt", "submit", "./local.sh", "--msg", "test"]);
        assert!(result.is_err());
    }

    #[test]
    fn test_help_output() {
        // Verify help can be displayed correctly
        let result = parse_args_from(&["vkt", "--help"]);
        assert!(result.is_err()); // --help returns Error::Exit
    }

    #[test]
    fn test_version_flag() {
        let result = parse_args_from(&["vkt", "--version"]);
        assert!(result.is_err()); // --version returns Error::Exit
    }
}
